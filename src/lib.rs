


use pcap_parser::*;
use pcap_parser::traits::PcapReaderIterator;

use pcap_parser::data::{get_packetdata_ethernet, get_packetdata_ipv4, PacketData};
use etherparse::{SlicedPacket,InternetSlice,TransportSlice,IpNumber};

use std::io::*;
use std::fs::File;
use std::path::Path;
use std::error::Error;
use std::result::Result;

mod stream;
use stream::*;

pub mod config;

pub struct Converter {
    config: config::Config,
    streams: StreamTracker,

    ts_file: BufWriter<File>,
}

impl Converter {

    fn check_mpegts(&self, data: & [u8]) -> bool
    {
        // Basic sync for sync byte at the beginning of every packet
        data[0] == 0x47
    }
    
    fn on_ipv4<'a>(&mut self, value: SlicedPacket<'a>)
    {
        let mut is_udp : bool = false;
        let mut src_addr : [u8; 4] = [0; 4];
        let mut dst_addr : [u8; 4] = [0; 4];
 
        // println!("link: {:?}", value.link);
        // println!("vlan: {:?}", value.vlan);
        //     println!("transport: {:?}", value.transport);

        match value.net {
            Some(InternetSlice::Ipv4(ref _ipv4)) => {
                let header = _ipv4.header();
                //println!("src: {:?} dst: {:?}", header.source(), header.destination());
                if header.protocol() == IpNumber::UDP {
                    is_udp = true;
                    src_addr = header.source();
                    dst_addr = header.destination();
                }
            },
            _ => ()
        }
        if is_udp {
            match value.transport {
                Some(TransportSlice::Udp(_udp)) => {
                    //println!("sport: {} dport: {}", _udp.source_port(), _udp.destination_port());
                    if self.check_mpegts(_udp.payload()) {
               
                        // Build stream object here. This represents the current
                        // packets source and destination, is what identifies
                        // the current udp stream.
                        let stream = UdpStream::new(src_addr, _udp.source_port(), dst_addr, _udp.destination_port());

                        // Now that we have an identifier, we use it to
                    //   println!("{:?}", stream);
                        // contains and update don't need to reference stream.

                        let index = self.streams.update(stream);

                        // do nothing if we are querying only
                        if self.config.query {
                            return ()
                        }

                        match index {
                            Some(idx) => {
                                if self.config.stream.is_some_and(|x| x == idx) {
                                    let _ = self.ts_file.write(_udp.payload());
                                }
                            }
                            None => ()
                        }
                    }
                },
                _ => ()
            }
        }
    }

    fn parse_ipv4(&mut self, data: & [u8])
    {
        match SlicedPacket::from_ip(data) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => {
                self.on_ipv4(value);
            }
        } 
    }

    fn parse_ether(&mut self, data: & [u8])
    {
        match SlicedPacket::from_ethernet(data) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => {
                self.on_ipv4(value);
            }
        }
    }

    fn parse_block<'a>(&mut self, linktype: Linktype, _b: & LegacyPcapBlock<'a>)
    {
    //   println!("Block {} {} {} {}", _b.ts_sec, _b.ts_usec, _b.caplen, _b.origlen);
    //   println!("Linktype: {}", linktype);

        if linktype == Linktype::LINUX_SLL2 {
            // Unfortunately, while pcap_parser handles a form of this linktype, it
            // does not handle the kind generated by tcpdump on an Nvidia Jetson device, which is
            // Version 2 of the SLL header. So we'll skip over it manually and go
            // straight to the IP layer. (There is no Ethernet layer)
            // This linktype can happen when you do a tcpdump on 'any' interface.
            // See https://gitlab.com/wireshark/wireshark/-/wikis/sll and
            // https://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL2.html for more info

            // We'll skip 20 bytes!
            const SLL2_HEADER_LEN: usize = 20;
            let ipv4_data = get_packetdata_ipv4(&_b.data[SLL2_HEADER_LEN..], (_b.caplen as usize) - SLL2_HEADER_LEN);
            match ipv4_data {
                Some(pkt_data) => {
                    match pkt_data {
                        PacketData::L3(_eth_type, _data) => {
                            self.parse_ipv4(_data);
                        },
                        PacketData::Unsupported(_) => { todo!(); },
                        _ => { println!("what"); }
                    }
                },
                None => println!("Unsupported link type."),
            }
        }
        else if linktype == Linktype::ETHERNET {
            let eth_data = get_packetdata_ethernet(_b.data, _b.caplen as usize);
            match eth_data {
                Some(pkt_data) => {
                    match pkt_data {
                        PacketData::L2(_data) => {
                            self.parse_ether(_data);
                        },
                        PacketData::Unsupported(_) => { todo!(); },
                        _ => { println!("what"); }
                    }
                },
                None => println!("Unsupported link type."),
            }
        }

        // use linktype to parse b.data()
    }


    pub fn run(_config: config::Config) -> Result<(), Box<dyn Error>>
    {
        let mut converter = Converter{ 
            config: _config.clone(),
            streams: StreamTracker::new(), 
            ts_file: BufWriter::new(File::create(_config.output)?)
        };

        println!("Opening file {}", _config.input);
    
        let file = File::open(Path::new(&_config.input))?;
        let mut linktype = Linktype::NULL;
         
        let mut reader = LegacyPcapReader::new(65536, file)?;
        loop {
            match reader.next() {
                Ok((offset, block)) => {
              //      println!("got new block: {}", offset);
                    match block {
                        PcapBlockOwned::LegacyHeader(_hdr) => {
                            println!("Legacy header: {}", _hdr.network);
                            linktype = _hdr.network;
                            // save hdr.network (linktype)
                        },
                        PcapBlockOwned::Legacy(_b) => {
                            converter.parse_block(linktype, &_b);
                        },
                        PcapBlockOwned::NG(_) => {
                            println!("unreachable?");
                        //    unreachable!();
                        }
                    }
                    reader.consume(offset);
                },
                Err(PcapError::Eof) => break,
                Err(PcapError::Incomplete(_)) => {
                    reader.refill().unwrap();
                },
                Err(e) => panic!("error while reading: {:?}", e),
            }
        }
    
        converter.ts_file.flush()?;
        
        println!("Streams found:\n{}", converter.streams);
    
        Ok(())
    }
}
