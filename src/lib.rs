


use pcap_parser::*;
use pcap_parser::traits::PcapReaderIterator;

use pcap_parser::data::{get_packetdata_ethernet, get_packetdata_ipv4, PacketData};
use etherparse::{InternetSlice, IpNumber, SlicedPacket, TransportSlice, UdpSlice};

use std::io::*;
use std::fs::File;
use std::path::Path;
use std::error::Error;
use std::result::Result;

mod stream;
use stream::*;

pub mod config;

pub struct Converter {
    config: config::Config,
    streams: StreamTracker,
    ts_file: Option<BufWriter<File>>
}

impl Converter {

    fn check_mpegts(&self, data: & [u8]) -> bool
    {
        // Basic sync for sync byte at the beginning of every packet
        data[0] == 0x47
    }

    fn on_udp(&mut self, header: etherparse::Ipv4HeaderSlice, udp: UdpSlice) -> bool
    {
        if self.check_mpegts(udp.payload()) {
               
            // Build stream object here. This represents the current
            // packets source and destination, is what identifies
            // the current udp stream.
            let stream = UdpStream::new(
                header.source(), 
                udp.source_port(), 
                header.destination(), 
                udp.destination_port());

            //   println!("{:?}", stream);
            // Update the current stream and grab it's index
            let index = self.streams.track(stream);

            // do nothing if we are querying only
            if self.config.query {
                return true;
            }

            // If we are dumping all streams
            if self.config.all {
                self.streams.dump_payload(index, udp.payload());
            }
            else {
                // Otherwise just the specified or default stram
                if self.config.stream.is_some_and(|s| s == index) {
                    self.streams.dump_payload(index, udp.payload());
                }
            }
        }
        else {
            return false;
        }
        return true;
    }

    fn on_ipv4<'a>(&mut self, value: SlicedPacket<'a>)
    {
        // println!("link: {:?}", value.link);
        // println!("vlan: {:?}", value.vlan);
        //     println!("transport: {:?}", value.transport);

        match value.net {
            Some(InternetSlice::Ipv4(ref _ipv4)) => {
                let ipv4_header = _ipv4.header();
                //println!("src: {:?} dst: {:?}", header.source(), header.destination());
                if ipv4_header.protocol() == IpNumber::UDP {
                    match value.transport {
                        Some(TransportSlice::Udp(udp)) => {
                            //println!("sport: {} dport: {}", _udp.source_port(), _udp.destination_port());
                            
                            self.on_udp(ipv4_header, udp);
                        },
                        _ => ()
                    }
                }
            },
            _ => ()
        }
    }

    fn parse_ipv4(&mut self, data: & [u8])
    {
        match SlicedPacket::from_ip(data) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => {
                self.on_ipv4(value);
            }
        } 
    }

    fn parse_ether(&mut self, data: & [u8])
    {
        match SlicedPacket::from_ethernet(data) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => {
                self.on_ipv4(value);
            }
        }
    }

    fn parse_block<'a>(&mut self, linktype: Linktype, _b: & LegacyPcapBlock<'a>)
    {
    //   println!("Block {} {} {} {}", _b.ts_sec, _b.ts_usec, _b.caplen, _b.origlen);
    //   println!("Linktype: {}", linktype);

        if linktype == Linktype::LINUX_SLL2 {
            // Unfortunately, while pcap_parser handles a form of this linktype, it
            // does not handle the kind generated by tcpdump on an Nvidia Jetson device, which is
            // Version 2 of the SLL header. So we'll skip over it manually and go
            // straight to the IP layer. (There is no Ethernet layer)
            // This linktype can happen when you do a tcpdump on 'any' interface.
            // See https://gitlab.com/wireshark/wireshark/-/wikis/sll and
            // https://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL2.html for more info

            // We'll skip 20 bytes!
            const SLL2_HEADER_LEN: usize = 20;
            let ipv4_data = get_packetdata_ipv4(&_b.data[SLL2_HEADER_LEN..], (_b.caplen as usize) - SLL2_HEADER_LEN);
            match ipv4_data {
                Some(pkt_data) => {
                    match pkt_data {
                        PacketData::L3(_eth_type, _data) => {
                            self.parse_ipv4(_data);
                        },
                        PacketData::Unsupported(_) => { todo!(); },
                        _ => { println!("what"); }
                    }
                },
                None => println!("Unsupported link type."),
            }
        }
        else if linktype == Linktype::ETHERNET {
            let eth_data = get_packetdata_ethernet(_b.data, _b.caplen as usize);
            match eth_data {
                Some(pkt_data) => {
                    match pkt_data {
                        PacketData::L2(_data) => {
                            self.parse_ether(_data);
                        },
                        PacketData::Unsupported(_) => { todo!(); },
                        _ => { println!("what"); }
                    }
                },
                None => println!("Unsupported link type."),
            }
        }

        // use linktype to parse b.data()
    }


    pub fn run(_config: config::Config) -> Result<(), Box<dyn Error>>
    {
        let input_path = Path::new(&_config.input);

        // If an output file is supplied, use that, otherwise derive
        // it from the input filename.
        let file_basename = match _config.output {
            Some(ref s) =>  s.clone(),
            None => {
                let file_stem = match input_path.file_stem() {
                    Some(stem) => {
                        stem.to_str().unwrap()
                    },
                    None => {
                        return Err(std::io::Error::other("Invalid input file. Could not derive output file").into());
                    }
                };
                file_stem.to_string()
            }
        };

        let mut converter = Converter{ 
            config: _config.clone(),
            streams: StreamTracker::new(file_basename), 
            ts_file: None,
        };

        let file = File::open(input_path)?;
        let mut linktype = Linktype::NULL;
         
        let mut reader = LegacyPcapReader::new(65536, file)?;
        loop {
            match reader.next() {
                Ok((offset, block)) => {
              //      println!("got new block: {}", offset);
                    match block {
                        PcapBlockOwned::LegacyHeader(_hdr) => {
                            println!("Legacy header: {}", _hdr.network);
                            linktype = _hdr.network;
                            // save hdr.network (linktype)
                        },
                        PcapBlockOwned::Legacy(_b) => {
                            converter.parse_block(linktype, &_b);
                        },
                        PcapBlockOwned::NG(_) => {
                            println!("unreachable?");
                        //    unreachable!();
                        }
                    }
                    reader.consume(offset);
                },
                Err(PcapError::Eof) => break,
                Err(PcapError::Incomplete(_)) => {
                    reader.refill().unwrap();
                },
                Err(e) => panic!("error while reading: {:?}", e),
            }
        }
    
        let _ = converter.ts_file.is_some_and(|mut f| f.flush().is_ok());
        
        println!("Streams found:\n{}", converter.streams);
    
        Ok(())
    }
}
